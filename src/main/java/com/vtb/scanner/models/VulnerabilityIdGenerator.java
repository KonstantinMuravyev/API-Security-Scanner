package com.vtb.scanner.models;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * Утилита для генерации детерминированных ID уязвимостей
 * Использует SHA-256 для создания уникальных ID без коллизий
 */
public class VulnerabilityIdGenerator {
    
    /**
     * Генерирует детерминированный ID для уязвимости
     * 
     * @param type тип уязвимости
     * @param endpoint эндпоинт
     * @param method HTTP метод
     * @param paramName имя параметра (может быть null)
     * @param title заголовок уязвимости (может быть null)
     * @return детерминированный ID (первые 16 символов SHA-256 hash)
     */
    public static String generateId(VulnerabilityType type, String endpoint, 
                                    String method, String paramName, String title) {
        // Создаем уникальную строку из всех компонентов
        StringBuilder sb = new StringBuilder();
        sb.append(type != null ? type.name() : "UNKNOWN");
        sb.append("|");
        sb.append(endpoint != null ? endpoint : "N/A");
        sb.append("|");
        sb.append(method != null ? method : "N/A");
        sb.append("|");
        sb.append(paramName != null ? paramName : "");
        sb.append("|");
        sb.append(title != null ? title.substring(0, Math.min(50, title.length())) : "");
        
        // Генерируем SHA-256 hash
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(sb.toString().getBytes(StandardCharsets.UTF_8));
            
            // Берем первые 16 символов hex представления (32 hex символа = 16 байт)
            StringBuilder hexString = new StringBuilder();
            for (int i = 0; i < 8; i++) { // 8 байт = 16 hex символов
                String hex = Integer.toHexString(0xff & hash[i]);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            
            // Префикс для читаемости
            String prefix = type != null ? getTypePrefix(type) : "VULN";
            return prefix + "-" + hexString.toString().toUpperCase();
            
        } catch (NoSuchAlgorithmException e) {
            // Fallback на простой hash если SHA-256 недоступен (не должно быть)
            return "VULN-" + Math.abs(sb.toString().hashCode());
        }
    }
    
    /**
     * Получить короткий префикс для типа уязвимости
     */
    private static String getTypePrefix(VulnerabilityType type) {
        return switch (type) {
            case BOLA -> "BOLA";
            case SQL_INJECTION -> "SQL";
            case COMMAND_INJECTION -> "CMD";
            case SSRF -> "SSRF";
            case NOSQL_INJECTION -> "NOSQL";
            case LDAP_INJECTION -> "LDAP";
            case RATE_LIMIT_MISSING -> "RATE";
            case UNRESTRICTED_RESOURCE_CONSUMPTION -> "RES";
            case BROKEN_AUTHENTICATION -> "AUTH";
            case WEAK_AUTHENTICATION -> "WEAK";
            case BROKEN_OBJECT_PROPERTY -> "PROP";
            case BFLA -> "BFLA";
            case UNRESTRICTED_BUSINESS_FLOW -> "BFLOW";
            case CORS_MISCONFIGURATION -> "CORS";
            case SECURITY_MISCONFIGURATION -> "MISC";
            case IMPROPER_INVENTORY -> "INV";
            case UNSAFE_API_CONSUMPTION -> "UNSAFE";
            case EXCESSIVE_DATA_EXPOSURE -> "EXPOSE";
            case SENSITIVE_DATA_IN_URL -> "SENS";
            case GOST_VIOLATION -> "GOST";
            case FZ152_VIOLATION -> "FZ152";
            case SECRET_LEAK -> "SECRET";
            case DEBUG_ENDPOINT -> "DEBUG";
            case SHADOW_API -> "SHADOW";
            default -> "VULN";
        };
    }
}

